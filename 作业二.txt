#包括“../../../stack/stack.h”

#包括<stdio.h>
#include<string.h>

#define N_OPTR 9 //运算符总数

typedef enum { ADD， SUB， MUL， DIV， POW， FAC， L_P， R_P， EOE } Operator;//运算符集合
//加、减、乘、除、乘方、阶乘、左括号、右括号、起始符与终止符

const char pri[N_OPTR][N_OPTR] = { //运算符优先等级 [栈顶] [当前]
	/* |-------------------- 当 前 运 算 符 --------------------|*/
	/* + - * / ^ ！（ ） \0 */
	/* --  + */    '>'、“>”、“<”、“<”、“<”、“<”、“<”、“>”、“>”、”
	/* | - */ “>”， “>”， “<”， “<”， “<”， “<”， “<”， “>”， “>”， 
	/* 栈 * */ '>'， '>'， '>'， '>'， '<'， '<'， '<'， '>'， '>'，
	/* 顶 / */ “>”， “>”， “>”， “>”， “<”， “<”， “<”， “>”， “>”，
	/* 运 ^ */ '>'， '>'， '>'， '>'， '>'， '<'， '<'， '>'， '>'，
	/* 算 ！*/ “>”、“>”、“>”、“>”、“>”、“>”、“>”、“>”、“”、“”、“”、“”、“”、“”、”
	/* 符 （ */ '<'， '<'， '<'， '<'， '<'， '<'， '<'， '='， '  '，
	/* | ）*/ ''， ''，      '， '，  '，
	/* -- \0 */ '<'， '<'， '<'， '<'， '<'， '<'， '<'， '  '，'='
};



void readNumber（char*& p， Stack<float>& stk） { //将起始于p的子串解析为数值，并存入操作数栈
stk.push（（float）（*p - '0'））;//当前数位对应的数值进栈
	while （isdigit（*（++p）））） //只要后续还有紧邻的数字（即多位整数的情况），则
stk.push（stk.pop（） * 10 + （*p - '0'））;//弹出原操作数并追加新数位后，新数值重新入栈
	如果 （'.' ！= *p） 返回;//此后非小数点，则意味着当前操作数解析完成
	浮点分数 = 1;//否则，意味着还有小数部分
	while （isdigit（*（++p））） //逐位加入
stk.push（stk.pop（） + （*p - '0'） * （fraction /= 10））;小数部分
}

Operator optr2rank（char op） { //由运算符转译出编号
	开关 （操作） {
	案例 '+'：返回 ADD;//加
	案例 '-'：返回 SUB;//减
	案例 '*'：返回 MUL;//乘
	情况 '/'：返回 DIV;//除
	情况 '^'：返回战俘;乘
	案例“！”：返回 FAC;//阶乘
	案例 '（'：返回L_P;//左括号
	情况“）”：返回R_P;//右括号
	案例 '\0'：返回 EOE;起始符不终止符
	默认值：退出（-1）;//未知运算符
	}
}

char orderBetween（char op1， char op2） {//比较两个运算符之间的优先级
	返回 pri[optr2rank（op1）][optr2rank（op2）];
}



float calcu（char optr， float opnd） {//当符号为“！”时，重载一下函数
	整数结果 = OPND;
	for （int i = opnd - 1; i > 0; i--） {
结果 = 结果 * i;
	}
	返回结果;
}


float  calcu（float opnd1， char op， float opnd2） {
	浮点结果 = 1;
	switch （op） //判断运算符
	{
	情况 “+”：{
结果 = OPND1 + OPND2;
		返回结果;}
	案例 '-'： {
结果 = OPND1 - OPND2;
		返回结果;}
	情况 '*'： {
结果 = OPND1 * OPND2;
		返回结果;}
	案例 '/'： {
结果 = OPND1 / OPND2;
		返回结果;}
	案例 '^'：{
		for （int i = 0; i < opnd2; i++）
结果 *= OPND1;
		返回结果;}
	}开关
}

float evaluate（char* S/* char*& RPN*/） { //对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN
堆叠<浮子> opnd;
Stack<char> optr;运算数栈、运算符栈
选择。push（'\0'）;//尾哨兵'\0'也作为头哨兵首先入栈
	而（！empty（）） { //在运算符栈非空之前，逐个处理表达式中各字符
		if （isdigit（*S）） { //若当前字符为操作数，则
			readNumber（S， opnd）;
			//append（RPN， opnd.top（））;读入操作数，并将其接至RPN末尾
		}else //若当前字符为运算符，则
			switch （orderBetween（optr.top（）， *S）） {//视其不栈顶运算符之间优先级高低分别处理
			    case '<'： //栈顶运算符优先级更低时
选择。推（*S）;
S++;//计算推迟，当前运算符进栈
				    破;
			    case '='： //优先级相等（当前运算符为右括号或者尾部哨兵'\0'）时 
选择。流行();
S++;//脱括号并接收下一个字符
				    破;
			    case '>'： { //栈顶运算符优先级更高时，可实现相应的计算，并将结果重新入栈
				    字符操作 = 选择。流行(); 
					//append（RPN， op）;栈顶运算符出栈并续接至RPN末尾
				    if （'！' == op） { //若属于一元运算符
					    float pOpnd = opnd。流行（）;//只需取出一个操作数，并
奥彭德。push（calcu（op， pOpnd））;//实现一元计算，结果入栈
				    }else { //对于其它（二元）运算符
					    float pOpnd2 = opnd。pop（）， pOpnd1 = opnd.流行（）;//取出后、前操作数
奥彭德。push（calcu（pOpnd1， op， pOpnd2））;//实现二元计算，结入栈
				    }
				    破;
			    }
			    默认值：退出（-1）;//逢语法错误，不做处理直接退出
		    }开关
	}//while
	返回 opnd。流行（）;//弹出并返回最后的计算结果
}



int main() {
	夏亚[100];
cout << “请输入字符串：” << endl;
辛>> S;
cout <<s<<“=” << 评估 << endl;

}